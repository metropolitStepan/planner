# Планировщик спортивного мероприятия: пользовательский интерфейс и тонкий API-адаптер

Данный проект предоставляет графический пользовательский интерфейс (Frontend: Vite + React + TypeScript) и тонкий API-адаптер (FastAPI) для использования существующего скрипта планирования `planner.py`. Адаптер вызывает функции из `planner.py` напрямую (если они доступны) либо запускает скрипт как отдельный процесс и обменивается данными в формате JSON.

## 1. Назначение и область применения

Система предназначена для формирования расписания соревновательного дня на основе исходных данных и параметров планирования, вводимых пользователем. Проект ориентирован на локальный запуск и демонстрирует следующие процессы:
- загрузка исходных файлов (табличные данные);
- настройка параметров окна соревнований и ограничений;
- получение и визуализация расписания в виде таблицы.

## 2. Поддерживаемые данные и форматы

### 2.1. Входные файлы
Поддерживаются форматы:
- `.xlsx` (Microsoft Excel, UTF-8 или совместимая кодировка);
- `.csv` (разделитель — запятая, UTF-8).

Файл загружается через маршрут `/upload` API-адаптера и сохраняется на диск. Путь к последнему загруженному файлу передаётся в `planner.py` в параметре `params.options.lastUploadPath`.

### 2.2. Параметры планирования (структура запроса)
При формировании расписания интерфейс отправляет запрос формата:
```json
{
  `window`: { `date`: `YYYY-MM-DD`, `startTime`: `HH:MM`, `endTime`: `HH:MM` },
  `courts`: [ { `id`: `c1`, `name`: `Зал 1` }, { `id`: `c2`, `name`: `Зал 2` } ],
  `groups`: [ { `id`: `g1`, `name`: `Группа 1`, `size`: 10, `tags`: [] } ],
  `slotMinutes`: 15,
  `parallelLimit`: 2,
  `constraints`: [],
  `options`: {}
}
````

### 2.3 Ожидаемый формат результата от `planner.py`

Адаптер ожидает от `planner.py` JSON со следующей минимальной структурой:

```json
{
  `date`: `YYYY-MM-DD`,
  `slots`: [
    {
      `start`: `HH:MM`,
      `end`: `HH:MM`,
      `courtId`: `c1`,
      `groupId`: `g1`,
      `item`: `Индивидуальная`,
      `judge`: `ФИО`,
      `comment`: ``
    }
  ]
}
```

Если `planner.py` не возвращает корректный JSON, адаптер использует наивный алгоритм построения расписания (fallback), чтобы обеспечить непрерывность взаимодействия с системой.

## 3. Требования к окружению

* Операционные системы: macOS, Windows, Linux.
* Python 3.10+.
* Node.js 18+.

## 4. Структура репозитория

```
planner/
  api_adapter.py        # FastAPI-адаптер
  planner.py            # существующий backend-скрипт
  frontend/
    index.html
    src/
      main.tsx
      api/              # HTTP-клиент и типы
      components/       # UI-компоненты
      pages/            # Страницы интерфейса
```

## 5. Установка и запуск

### 5.1. Установка зависимостей API-адаптера (Python)

Выполняется в корневой директории репозитория.

```bash
python3 -m venv .venv
source .venv/bin/activate                 # Windows: .\.venv\Scripts\Activate.ps1
pip install fastapi uvicorn pydantic python-multipart
```

### 5.2. Запуск API-адаптера

```bash
uvicorn api_adapter:app --reload --port 8000
```

Проверка доступности:

```bash
curl http://127.0.0.1:8000/health
# {`status`:`ok`}
```

### 5.3. Установка и запуск пользовательского интерфейса (Frontend)

```bash
cd frontend
npm i
npm run dev
# открыть http://localhost:5173
```

## 6. Взаимодействие с системой (пользовательский сценарий)

1. Запустить API-адаптер (см. п. 5.2).
2. Запустить фронтенд (см. п. 5.3) и открыть `http://localhost:5173`.
3. Перейти на вкладку «Загрузка данных» и отправить файл `.xlsx` или `.csv`. Загруженный файл сохраняется на диск, идентификатор и путь возвращаются клиенту.
4. Перейти на вкладку «Параметры», задать:
   * дату соревновательного дня;
   * временное окно (начало и окончание);
   * длительность слота и допустимое число параллельных потоков;
   * список площадок и групп (минимум по одному элементу);
5. Нажать «Сформировать расписание». Интерфейс отправит запрос. В ответ будет выдан идентификатор плана и массив слотов.
6. Перейти на вкладку «Расписание». Данные отображаются в табличном виде.

## 7. Принципы интеграции адаптера с `planner.py`

1. Адаптер пытается импортировать из `planner.py` одну из функций: `generate_schedule`, `plan`, `run` или `main` и вызвать её с единственным параметром `params` (словарь из запроса).
2. При отсутствии указанных функций адаптер запускает `planner.py` как процесс и передаёт входные данные в `stdin` (JSON). Ожидается, что `stdout` вернёт корректный JSON.
3. При невозможности получить корректный JSON включается наивный алгоритм (fallback), формирующий расписание по фиксированным правилам (round-robin по площадкам, равные слоты).

Таким образом, существующий код `planner.py` не требуется изменять. Парсинг загруженного файла при необходимости выполняется внутри `planner.py`, путь к последнему файлу доступен в `params.options.lastUploadPath`.

## 8. Обработка ошибок и диагностика

* Ошибки уровня API отображаются в интерфейсе в виде баннера.
* Для диагностики сетевых проблем рекомендуется использовать инструменты разработчика браузера (вкладка Network) и логи процесса `uvicorn`.
* Проверка занятости порта (macOS/Linux):

  ```bash
  lsof -i :8000
  ```

## 9. Сборка интерфейса для распространения

```bash
cd frontend
npm run build
```

Результат помещается в папку `frontend/dist` и может раздаваться любым статическим веб-сервером. В составе данного проекта раздача статики через FastAPI не предусмотрена.

## 10. Минимальные требования к корректности (Definition of Done)

* Интерфейс обеспечивает загрузку данных, настройку параметров и визуализацию полученного расписания.
* Ошибки API и валидации корректно отображаются пользователю.
* Проект запускается на чистой машине командами, указанными в разделе 5.

## 11. Ограничения текущей версии

* Долговременное хранение расписаний отсутствует (данные сохраняются в памяти процесса адаптера). При перезапуске адаптера результаты теряются.
* При отсутствии корректного JSON из `planner.py` используется наивный алгоритм, не учитывающий сложные ограничения.
* Визуализация представлена в табличной форме; графические таймлайны не реализованы.
* Валидация входных данных в интерфейсе базовая; при необходимости её следует расширить.

## 12. Ожидаемый формат ввода planner.py

Точка входа - `generate_schedule`. Оджидается один параметр: словарь со следующими ключами:
- `options.lastUploadPath` - строка, путь к загруженному excel-документу с данными (см. ниже)
- `window.date` - строка, дата проведения соревнования
- `restTime` - целое число, время на отдых команде. По умолчанию 0.
- `evaluateTime` - целое число, поправка на организационное время. По умолчанию 0.

На вход также ожидается excel-документ со следующей структурой:
- Лист `Упражнения` - содержит информацию об упражнениях:
  - `Название` - название упражнения, строка
  - Длительность - длительность выполнения упражнения одним человеком в минутах, рациональное число
- Лист `Этапы` - содержит информацию об этапах:
  - `МаксимумУчастников` - максимальное количество участников на этом этапе
- Лист `Корты` - содержит информацию о площадках:
  - `Корт` - название/идентификатор площадки, строка. Может повторяться, если в работе площадки есть перерывы
  - `Открытие` - время начала периода работы
  - `Закрытие` - время конца периода работы
- Лист `Группы` - содержит информацию о командах/группах участников:
  - `ИмяГруппы` - строка, название/идентификатор группы
  - `КоличествоУчастников` - целое число, количество человек в группе
  - Упражнение - название упражнения, строка, соответствует значению столбца `Название` в листе `Упражнения`
  - `МинимальноеВремяНачала` - наиболее раннее время для размещения команды в расписании, опционально.
  - `МаксимальноеВремяОкончания` - время, к которому команда должна пройти все этапы, опционально.
